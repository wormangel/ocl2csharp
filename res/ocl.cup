import java_cup.runtime.*;
import xmiParser.*;

action code {:
	
	private final int INCLUDES = 1;
	private final int EXCLUDES = 2;
	private final int EXISTS = 3;
	private final int FORALL = 4;
	private final int SELECT = 5;
	private final int SIZE = 6; 
			
	private String currentContext;
	private String fullContext;
	
	private int numEntrada = 0;
	
	private String getClassContext(String fullContext) {
		int index = fullContext.indexOf("::");
		return fullContext.substring(0,index);				
	}
	
	private String getOperationName(String fullContext) {
		int index1 = fullContext.indexOf("::");
		int index2 = fullContext.indexOf("(");
		return fullContext.substring(index1+2,index2);
	}
	
	private String getResultType(String fullContext) {
		String[] tokens = fullContext.split(":");
		int length = tokens.length;
		return tokens[length-1];
	}
	
	// GERAÇÃO DE CÓDIGO
	
	private void GenAuxMethod(String code) { System.out.println(code);} // Imprime o codigo gerado na tela
	
	private String getFormalParameters(boolean includeResult) {
		if (includeResult) {
			if(formalParameters.equals("")) {
				return formalParameters + "object result";
			} else {
				return formalParameters + ",object result";
			}
		} else {
			return formalParameters;
		}
	}
	
	private String getParamNames(boolean includeResult){
		String names = "";
		String params = getFormalParameters(includeResult);
		if (params.equals(""))
			return "";
		String[] semVirgulas = params.split(",");
		for(String s : semVirgulas){
			String[] semEspacos = s.split(" ");
			names += semEspacos[1] + ",";
		}
		if (names.endsWith(","))
			names = names.substring(0,names.length()-1);
		return names;
	}
	private String formalParameters = "";
	private boolean isResult;
	
	// Invariantes
	private int invCount = 0;
	private String getInvName() { invCount++; return "CheckInv" + invCount;}
	
	// Pré e pós condições
	private int preCount = 0;
	private String getPreName() { preCount++; return "CheckPre" + preCount;}
	private String lastPreName() { return "CheckPre" + preCount;}
	private int posCount = 0;
	private String getPosName() { posCount++; return "CheckPos" + posCount;}
	private String lastPosName() { return "CheckPos" + posCount;} 
	
	// forAll
	private int forAllCount = 0;
	private String getForAllName() { forAllCount++; return "ForAll"+forAllCount; }
	
	// select
	private int selectCount = 0;
	private String getSelectName() { selectCount++; return "Select"+selectCount; } 
	
	// exists
	private int existsCount = 0;
	private String getExistsName() { existsCount++; return "Exists"+existsCount; }
		
:}

/* Terminais  */

terminal            PRE, POS, INV, SELECT, EXISTS, FORALL, IF, THEN, ELSE, IMPLIES, INCLUDES, EXCLUDES, SIZE, CONTEXT, LPAREN, RPAREN, RESULT;
terminal			LCOLCH, RCOLCH, LCHAVE, RCHAVE, DOISPONTOS, QUATROPONTOS, VIRGULA, IGUAL, DIFF, MENORQ, MAIORQ, MENORIGUAL, MAIORIGUAL, SETA, PONTOPONTO;
terminal			PONTO, SHARP, PONTOVIRGULA, BARRA, MAIS, MENOS, VEZES, DIVIDIR;
terminal 			VOID, AND, OR, XOR, NOT, ENDIF, INTTYPE, REALTYPE, PACKAGE, ENDPACKAGE;
terminal Atributos	STRING, BOOLEAN, NUMBER, SET, BAG, SEQUENCE, COLLECTION, INTEGER, REAL, TRUE, FALSE, ID;


/* Não terminais */

non terminal Atributos OCLFile, OCLConstraints, Constraint, ContextDeclaration, ContextBody, Stereotype, OCLExpression, OperationContext, ClassifierContext;
non terminal Atributos OperationName, FormalParameters,  ReturnType, FormalParameter, TypeSpecifier, CollectionType, SimpleTypeSpecifier, PathName, OCLLiteral;
non terminal Atributos BoolValue, Number;

// Expressões

non terminal Atributos PostFixExpression, LogicalExpression, NumberExpression, RelationalExpression, PropertyCall, PropertyCallExpression, AdditiveExpression, MultiplicativeExpression, UnaryExpression, PrimaryExpression, InvExpression, PreExpression, EqualityExpression;

// Operadores lógicos, aritméticos e relacionais

non terminal Atributos MultiplyOperator, PostfixOperator, RelationalOperator, UnaryOperator, AddOperator, LogicalOperator;

// Expressões condicionais

non terminal Atributos ConditionalExpression, IfExpression, ImpliesExpression;

// Coleções e expressões sobre condições

non terminal Atributos CollectionItems, CollectionExpression, LiteralCollection, CollectionOperations, SelectOperation, ExistsOperation, IncludesOperation, ExcludesOperation, ForAllOperation, SizeOperation, CollectionParameters;

/* Precedência dos terminais */

precedence left IMPLIES;
precedence left XOR;
precedence left OR;
precedence left AND;
precedence left DIFF, IGUAL;
precedence left MENORIGUAL, MAIORIGUAL, MENORQ, MAIORQ;
precedence left IF, THEN, ELSE, ENDIF;
precedence left MAIS, MENOS;
precedence left VEZES, DIVIDIR;
precedence left PONTO, SETA;

/* Regras */

// Regra Inicial

start with OCLFile;

// Regras para constraints

OCLFile ::= PACKAGE ID OCLConstraints ENDPACKAGE
		  | OCLConstraints;
				
OCLConstraints ::= Constraint OCLConstraints | Constraint;

Constraint ::= ContextDeclaration ContextBody {: currentContext = null; fullContext = null; isResult = false; formalParameters = ""; :};

ContextDeclaration ::= CONTEXT OperationContext:c {: currentContext = getClassContext((String)c.Value); fullContext = (String)c.Value; :}
					 | CONTEXT ClassifierContext:c {: currentContext = (String)c.Value; :};
				
ContextBody ::= InvExpression:i  {: numEntrada++; System.out.println(numEntrada + "\n"); System.out.println(i.Code); :}
			  | PreExpression:p {: numEntrada++; System.out.println(numEntrada + "\n"); System.out.println(p.Code); :};
				
InvExpression ::= INV DOISPONTOS OCLExpression:e 
				{: 
					if (e.Type != "boolean") {
						System.err.println("\nErro semantico.\nInvExpression ::= INV DOISPONTOS OCLExpression");
						System.err.println("Invariante deve ser boolean.");
						System.exit(0);
					} else {
						String code = "private void " + getInvName() + "() { " + 
						"if (!(" + e.Code +")) throw new Exception(\"Inv violada\");" + " }";
						RESULT = new Atributos("boolean",null,code);
					}
					 
				:}
				| INV ID:i DOISPONTOS OCLExpression:e
				{:
					if (e.Type != "boolean") {
						System.err.println("\nErro semantico.\nInvExpression ::= INV ID DOISPONTOS OCLExpression");
						System.err.println("Invariante deve ser boolean.");
						System.exit(0);
					} else {
						String code = "private void checkInv" + i.Value.toString()+ "() { " + 
							"if (!(" + e.Code +"))  throw new Exception(\"Inv violada\");" + " }";
			 			RESULT = new Atributos("boolean",null,code);
		 			}
				:} ;

PreExpression ::= PRE DOISPONTOS OCLExpression:e
				{:
					if (e.Type != "boolean"){
						System.err.println("\nErro semantico.\nPreExpression ::= PRE DOISPONTOS OCLExpression");
						System.err.println("Pré-condição deve ser boolean.");
						System.exit(0);
					} else {
						String code = "private void " + getPreName() + "(" + getFormalParameters(false) + ") { " + 
					  			"if (!(" + e.Code +")) throw new Exception(\"Pre violada\");" + " }";
						RESULT =  new Atributos("boolean",null,code); 
					}
				:}
				| PRE ID:i DOISPONTOS OCLExpression:e
				{:
					if (e.Type != "boolean"){
						System.err.println("\nErro semantico.\nPreExpression ::= PRE ID DOISPONTOS OCLExpression");
						System.err.println("Pré-condição deve ser boolean.");
						System.exit(0);
					} else {
						String code = "private void CheckPre" +i.Value.toString() + "(" + getFormalParameters(false) + ") { " + 
								"if (!(" + e.Code + ")) throw new Exception(\"Pre violada\");" + " }";
						RESULT = new Atributos("boolean",null,code); 
					}
				:}
				| POS DOISPONTOS OCLExpression:e
				{:
					if (e.Type != "boolean"){
						System.err.println("\nErro semantico.\nPreExpression ::= POS DOISPONTOS OCLExpression");
						System.err.println("Pós-condição deve ser boolean.");
						System.exit(0);
					} else {
						String code;
						if(isResult){
				  			code = "private void " +getPosName() + "(" + getFormalParameters(true) + ") { " + 
				  				"if (!(" + e.Code +")) throw new Exception(\"Pos violada\");" + " }" +
				  				"private void " + getOperationName(fullContext) + "Checked" + "(" + getFormalParameters(false) + ") {" + 
				  				"object result = " + getOperationName(fullContext) + "(" + getParamNames(false) + ");" + lastPosName() +
				  				"(" + getParamNames(true) + ");" + " }"; 
				  		} else {
				  			code = "private void " +getPosName() + "(" + getFormalParameters(false) + ") { " + 
				  				"if (!(" + e.Code +")) throw new Exception(\"Pos violada\");" + " }"; 
				  		}
				  		RESULT = new Atributos("boolean",null,code); 
			  		}			  		
				:}
				| POS ID:i DOISPONTOS OCLExpression:e
				{:
					if (e.Type != "boolean"){
						System.err.println("\nErro semantico.\nPreExpression ::= POS ID DOISPONTOS OCLExpression");
						System.err.println("Pós-condição deve ser boolean.");
						System.exit(0);
					} else {
						String code;
				  		if(isResult){
				  			code = "private void CheckPos" + i.Value.toString() + "(" + getFormalParameters(true) + ") { " + 
				  				"if (!(" + e.Code +")) throw new Exception(\"Pos violada\");" + " }" + 
				  				"private void " + getOperationName(fullContext) + "Checked" + "(" + getFormalParameters(false) + ") {" + 
				  				"object result = " + getOperationName(fullContext) + "(" + getParamNames(false) + ");" + "CheckPos" + i.Value.toString() + 
				  				"(" + getParamNames(true) + ");" + " }";
				  		} else {
				  			code = "private void CheckPos" + i.Value.toString() + "(" + formalParameters + ") { " + 
				  				"if (!(" + e.Code +")) throw new Exception(\"Pos violada\");" + " }";
		  				} 
		  				RESULT = new Atributos("boolean",null,code);
	  				}
	  			:}
				
				| PRE DOISPONTOS OCLExpression:e1 POS DOISPONTOS OCLExpression:e2
				{: 
					if (e1.Type != "boolean" || e2.Type != "boolean"){
						System.err.println("\nErro semantico.\nPreExpression ::= PRE DOISPONTOS OCLExpression POS DOISPONTOS OCLExpression");
						System.err.println("Pré e pós-condições deve ser boolean.");
						System.exit(0);
					} else {
						String code;
						if(isResult) {
							code = "private void " +getPreName() + "(" +  getFormalParameters(false) + ") { " + "if (!(" + e1.Code +")) throw new Exception(\"Pre violada\");" + " }"
								+"private void " + getPosName() + "(" + getFormalParameters(true) + ") { " + "if (!(" + e2.Code +")) throw new Exception(\"Pos violada\");" + " }"
								+"private void " + getOperationName(fullContext) + "Checked" + "(" + getFormalParameters(false) + ") { " + lastPreName() + 
								"(" + getParamNames(false) +  ");" + "object result = " + getOperationName(fullContext) + "(" + getParamNames(false) + ");" + lastPosName() + "(" + getParamNames(true) + ");" + " }";
						} else {
							code = 	"private void " +getPreName() + "(" +  getFormalParameters(false) + ") { " + "if (!(" + e1.Code +")) throw new Exception(\"Pre violada\");" + " }"
							+"private void " + getPosName() + "(" + getFormalParameters(false) + ") { " + "if (!(" + e2.Code +")) throw new Exception(\"Pos violada\");" + " }"
							+"private void " + getOperationName(fullContext) + "Checked" + "(" + getFormalParameters(false) + ") { " + lastPreName() + 
							"(" + getParamNames(false) +  ");" + getOperationName(fullContext) + "(" + getParamNames(false) + ");" + lastPosName() + "(" + getParamNames(false) + ");" + " }";
						}
					  	RESULT = new Atributos("boolean",null,code);
				  	}	
				:}
				| PRE ID:i1 DOISPONTOS OCLExpression:e1 POS ID:i2 DOISPONTOS OCLExpression:e2
				{:
					if (e1.Type != "boolean" || e2.Type != "boolean"){
						System.err.println("\nErro semantico.\nPreExpression ::= PRE ID DOISPONTOS OCLExpression POS ID DOISPONTOS OCLExpression");
						System.err.println("Pré e pós-condições deve ser boolean.");
						System.exit(0);
					} else {
						String code;
						if(isResult){
						  	code = "private void CheckPre" + i1.Value.toString() + "(" + getFormalParameters(false) + ") { " + 
						  		"if (!(" + e1.Code +")) throw new Exception(\"Pre violada\");" + " }" +
								"private void CheckPos" + i2.Value.toString() + "(" + getFormalParameters(true) + ") { " + 
								"if (!(" + e2.Code +")) throw new Exception(\"Pos violada\");" + " }" +
								"private void " + getOperationName(fullContext) + "Checked" + "(" + getFormalParameters(false) + ") { " + "CheckPre" + i1.Value.toString() + 
								"(" + getParamNames(false) +  ");" + "object result = " + getOperationName(fullContext) + "(" + getParamNames(false) + ");" + "CheckPos" + i2.Value.toString() + "(" + getParamNames(true) + ");" + " }";
						} else {
							code = "private void CheckPre" + i1.Value.toString() + "(" + getFormalParameters(false) + ") { " + 
						  		"if (!(" + e1.Code +")) throw new Exception(\"Pre violada\");" + " }" +
								"private void CheckPos" + i2.Value.toString() + "(" + getFormalParameters(false) + ") { " + 
								"if (!(" + e2.Code +")) throw new Exception(\"Pos violada\");" + " }" +
								"private void " + getOperationName(fullContext) + "Checked" + "(" + getFormalParameters(false) + ") { " + "CheckPre" + i1.Value.toString() + 
								"(" + getParamNames(false) +  ");" + "object result = " + getOperationName(fullContext) + "(" + getParamNames(false) + ");" + "CheckPos" + i2.Value.toString() + "(" + getParamNames(false) + ");" + " }";
						}
						RESULT = new Atributos("boolean",null,code);
					}
				:};

OperationContext ::= ID:i QUATROPONTOS PropertyCall:p
					{: RESULT = new Atributos("string", i.Value.toString() + "::" + p.Value.toString(), ""); :}
				   | ID:i QUATROPONTOS PropertyCall:p DOISPONTOS TypeSpecifier:t
				   	{:
				   		if (!XmiParser.isValidOperation(i.Value.toString(), p.Value.toString(), t.Value.toString())){
				   			System.err.println("\nErro semantico.\nOperationContext ::= ID QUATROPONTOS PropertyCall DOISPONTOS TypeSpecifier");
							System.err.println("Operação inválida: " + p.Value.toString());
							System.exit(0);
				   		} else { 
				   			RESULT = new Atributos("string", i.Value.toString() + "::" + p.Value.toString() + ":" + t.Value.toString(), ""); 
				   		}	
			   		:};
				
ClassifierContext ::= ID:i DOISPONTOS ID
					{:
						if (!XmiParser.isValidClass(i.Value.toString())) {
							System.err.println("\nErro semantico.\nClassifierContext ::= ID DOISPONTOS ID");
							System.err.println("Classe nao existe: " + i.Value);
							System.exit(0);
						} else {
							RESULT = new Atributos("string", i.Value.toString(), null);
						}
					:}
					| ID:i
					{:
						if (!XmiParser.isValidClass(i.Value.toString())){
								System.err.println("\nErro semantico.\nClassifierContext ::= ID");
								System.err.println("Classe nao existe: " + i.Value);
								System.exit(0);
						} else {
							RESULT = new Atributos("string", i.Value.toString(), null);
						}
					:} ;

// Expressões 

OCLExpression ::= LogicalExpression:e {: RESULT = e; :};

LogicalExpression ::= RelationalExpression:e {: RESULT = e; :}
				| RelationalExpression:e1 LogicalOperator:o LogicalExpression:e2
				{:
				
				String tipo1 = e1.Type;
				String tipo2 = e2.Type;
				
				if(e1.Type == "id"){
					if (!XmiParser.isValidPath(currentContext, e1.Value.toString())){
						System.err.println("\nErro semantico.\nLogicalExpression ::= RelationalExpression:e1 LogicalOperator:o LogicalExpression:e2");
						System.err.println("Identificador invalido.");
						System.exit(-1);
					} else {
						tipo1 = XmiParser.getType(currentContext, e1.Value.toString());
					}
				}
				
				if(e2.Type == "id"){
					if (!XmiParser.isValidPath(currentContext, e2.Value.toString())){
						System.err.println("\nErro semantico.\nLogicalExpression ::= RelationalExpression:e1 LogicalOperator:o LogicalExpression:e2");
						System.err.println("Identificador invalido.");
						System.exit(-1);
					} else {
						tipo2 = XmiParser.getType(currentContext, e2.Value.toString());
					}
				}
				
				if (tipo1 != "boolean" || tipo2 != "boolean"){
					System.err.println("\nErro semantico.\nLogicalExpression ::= RelationalExpression LogicalOperator LogicalExpression");
					System.err.println("Operandos devem ser do tipo boolean.");
					System.exit(-1);
				} else {
					String code = e1.Code + " " + o.Code + " " + e2.Code;
					RESULT = new Atributos("boolean", null, code);				
				}
				:};
				
RelationalExpression  ::= AdditiveExpression:e {: RESULT = e; :}  
				| AdditiveExpression:e1 RelationalOperator:o RelationalExpression:e2
				{:
				
				String tipo1 = e1.Type;
				String tipo2 = e2.Type;
				
				if(e1.Type == "id"){
					if (!XmiParser.isValidPath(currentContext, e1.Value.toString())){
						System.err.println("\nErro semantico.\nRelationalExpression ::= AdditiveExpression RelationalOperator RelationalExpression");
						System.err.println("Identificador invalido.");
						System.exit(-1);
					} else {
						tipo1 = XmiParser.getType(currentContext, e1.Value.toString());
					}
				}
				
				if(e2.Type == "id"){
					if (!XmiParser.isValidPath(currentContext, e2.Value.toString())){
						System.err.println("\nErro semantico.\nRelationalExpression ::= AdditiveExpression RelationalOperator RelationalExpression");
						System.err.println("Identificador invalido.");
						System.exit(-1);
					} else {
						tipo2 = XmiParser.getType(currentContext, e2.Value.toString());
					}
				}
				
				String code = e1.Code + " " + o.Code + " " + e2.Code;
				
				if ( (o.Value.equals("=")) || (o.Value.equals("!=")) ){
				
					// Numeros
					
					if ( (tipo1 == "integer" && tipo2 == "double") || (tipo1 == "double" && tipo2 == "integer") ||
						 (tipo1 == "double" && tipo2 == "double") || (tipo1 == "integer" && tipo2 == "integer") ){
					    RESULT = new Atributos("boolean", null, code);
				    } else {
				    
				    	// Outros tipos
						if (!tipo1.equals(tipo2)) {
							System.err.println("\nErro semantico.\nRelationalExpression ::= AdditiveExpression RelationalOperator RelationalExpression");
							System.err.println("Operandos devem ser do mesmo tipo para operacoes de (des)igualdade.");
							System.exit(-1);
						} else {
							RESULT = new Atributos("boolean", null, code);
						}
					}
				} else {
					if ( (tipo1 == "integer" && tipo2 == "double") || (tipo1 == "double" && tipo2 == "integer") ||
							    (tipo1 == "double" && tipo2 == "double") || (tipo1 == "integer" && tipo2 == "integer") ){
					    RESULT = new Atributos("boolean", null, code);
				    } else {
						System.err.println("\nErro semantico.\nRelationalExpression ::= AdditiveExpression RelationalOperator RelationalExpression");
						System.err.println("Operandos devem ser numeros inteiros ou reais.");
						System.exit(-1);			
					}
				}
				:};
				
AdditiveExpression ::= MultiplicativeExpression:e {: RESULT = e; :}
				| MultiplicativeExpression:e1 AddOperator:o AdditiveExpression:e2
				{:
				
				String tipo1 = e1.Type;
				String tipo2 = e2.Type;
				
				if(e1.Type == "id"){
					if (!XmiParser.isValidPath(currentContext, e1.Value.toString())){
						System.err.println("\nErro semantico.\nAdditiveExpression ::= MultiplicativeExpression AddOperator AdditiveExpression");
						System.err.println("Identificador invalido.");
						System.exit(-1);
					} else {
						tipo1 = XmiParser.getType(currentContext, e1.Value.toString());
					}
				}
				
				if(e2.Type == "id"){
					if (!XmiParser.isValidPath(currentContext, e2.Value.toString())){
						System.err.println("\nErro semantico.\nAdditiveExpression ::= MultiplicativeExpression AddOperator AdditiveExpression");
						System.err.println("Identificador invalido.");
						System.exit(-1);
					} else {
						tipo2 = XmiParser.getType(currentContext, e2.Value.toString());
					}
				}
				
				String code = e1.Code + " " + o.Code + " " + e2.Code;
				
				if (tipo1 == "integer" && tipo2 == "integer") {
					RESULT = new Atributos("integer", null, code);
				} else if ( (tipo1 == "integer" && tipo2 == "double") || (tipo1 == "double" && tipo2 == "integer") ||
						    (tipo1 == "double" && tipo2 == "double") ){
				    RESULT = new Atributos("double", null, code);
			    } else {
					System.err.println("\nErro semantico.\nAdditiveExpression ::= MultiplicativeExpression AddOperator AdditiveExpression");
					System.err.println("Operandos devem ser numeros inteiros ou reais.");
					System.exit(-1);			
				}
				:};
				
MultiplicativeExpression ::= UnaryExpression:e {: RESULT = e; :}
				| UnaryExpression:e1 MultiplyOperator:o MultiplicativeExpression:e2
				{:
				
				String tipo1 = e1.Type;
				String tipo2 = e2.Type;
				
				if(e1.Type == "id"){
					if (!XmiParser.isValidPath(currentContext, e1.Value.toString())){
						System.err.println("\nErro semantico.\nMultiplicativeExpression ::= UnaryExpression MultiplyOperator MultiplicativeExpression");
						System.err.println("Identificador invalido.");
						System.exit(-1);
					} else {
						tipo1 = XmiParser.getType(currentContext, e1.Value.toString());
					}
				}
				
				if(e2.Type == "id"){
					if (!XmiParser.isValidPath(currentContext, e2.Value.toString())){
						System.err.println("\nErro semantico.\nMultiplicativeExpression ::= UnaryExpression MultiplyOperator MultiplicativeExpression");
						System.err.println("Identificador invalido.");
						System.exit(-1);
					} else {
						tipo2 = XmiParser.getType(currentContext, e2.Value.toString());
					}
				}
				
				String code =  e1.Code + " " + o.Code + " " + e2.Code;
				
				if (tipo1 == "integer" && tipo2 == "integer") {
					RESULT = new Atributos("integer", null, code);
				} else if ( (tipo1 == "integer" && tipo2 == "double") || (tipo1 == "double" && tipo2 == "integer") ||
						    (tipo1 == "double" && tipo2 == "double") ){
				    RESULT = new Atributos("double", null, code);
			    } else {
					System.err.println("\nErro semantico.\nMultiplicativeExpression ::= UnaryExpression MultiplyOperator MultiplicativeExpression");
					System.err.println("Operandos devem ser numeros inteiros ou reais.");
					System.exit(-1);			
				}
				:};
				
UnaryExpression ::= PrimaryExpression:e {: RESULT = e; :}
				| UnaryOperator:o UnaryExpression:e
				{:
				
				String tipo = e.Type;
				
				if(e.Type == "id"){
					if (!XmiParser.isValidPath(currentContext, e.Value.toString())){
						System.err.println("\nErro semantico.\nUnaryExpression ::= UnaryOperator UnaryExpression");
						System.err.println("Identificador invalido.");
						System.exit(-1);
					} else {
						tipo = XmiParser.getType(currentContext, e.Value.toString());
					}
				}
				
				if (o.Value.equals("not")){
					if (tipo != "boolean") {
						System.err.println("\nErro semantico.\nUnaryExpression ::= UnaryOperator UnaryExpression");
						System.err.println("Operador de negacao (not) deve ser usado em expressões booleanas.");
						System.exit(-1);
					} else {
						String code = o.Code + e.Code;
						RESULT = new Atributos("boolean", null, code);
					}
				} else { // se for seta
						System.err.println("\nErro semantico.\nUnaryExpression ::= UnaryOperator UnaryExpression");
						System.err.println("Operador seta só deve ser usado em coleções.");
						System.exit(-1);
				}
				:}
				
				| PrimaryExpression:e1 UnaryOperator:o UnaryExpression:e2
				{:
				
				String tipo = e1.Type;
				
				if(e1.Type == "id"){
					if (!XmiParser.isValidPath(currentContext, e1.Value.toString())){
						System.err.println("\nErro semantico.\nUnaryExpression ::= UnaryOperator UnaryExpression");
						System.err.println("Identificador invalido.");
						System.exit(-1);
					} else {
						tipo = XmiParser.getType(currentContext, e1.Value.toString());
					}
				}
			
				if (o.Value.equals("->") && tipo != "collection") {
					System.err.println("\nErro semantico.\nUnaryExpression ::= PrimaryExpression UnaryOperator UnaryExpression");
					System.err.println("Operador seta só deve ser usado em coleções.");
					System.exit(-1);
				} else {
					switch (e2.ColKind) {
							case INCLUDES:
								RESULT = new Atributos("boolean",null,e1.Code + "." + e2.Code, e2.ColKind);
								break;
							case EXCLUDES:
								RESULT = new Atributos("boolean",null,"!(" + e1.Code + "." + e2.Code + ")", e2.ColKind);
								break;
							case EXISTS:
								RESULT = new Atributos("boolean",null,e2.Code + "(" + e1.Code + ")", e2.ColKind); break; 
							case FORALL:
								RESULT = new Atributos("boolean", null, e2.Code + "(" + e1.Code + ")", e2.ColKind);
								break;
							case SIZE:
								RESULT = new Atributos("integer", null, e1.Code + e2.Code, e2.ColKind);
								break;
							case SELECT:
								RESULT = new Atributos("collection", null, e2.Code + "(" + e1.Code + ")", e2.ColKind);
								break;
						}
				}
				:};
				
PrimaryExpression ::= LiteralCollection:c {: RESULT = c; :}
				| IfExpression:c {: RESULT = c; :}
				| LPAREN OCLExpression:c RPAREN {: RESULT = new Atributos(c.Type,c.Value,"(" + c.Code + ")"); :}
				| CollectionExpression:c {: RESULT = c; :};

LiteralCollection ::= Number:n 		{: RESULT = n; :}
					| BoolValue:b 	{: RESULT = b; :}
					| STRING:s  	{: RESULT = s; :}
					| PropertyCall:p 	{: RESULT = p; :};
				
IfExpression ::= IF LogicalExpression:e1 THEN  LogicalExpression:e2 ELSE LogicalExpression:e3 ENDIF
				{:
					if (e1.Type != "boolean") {
						System.err.println("\nErro semantico.\nIfExpression ::= IF LogicalExpression THEN  LogicalExpression ELSE LogicalExpression ENDIF");
						System.err.println("Condicao deve ser boolean.");
						System.exit(-1);	
					}
					RESULT = new Atributos(null, null, e1.Code + "?" + e2.Code + " : " + e3.Code);
				:};		

//Expressões em coleções	
			
CollectionExpression ::= CollectionOperations:c {: RESULT = c; :} ;

CollectionOperations ::= SelectOperation:s {: RESULT = s; :}
				|ExistsOperation:s {: RESULT = s; :}
				|IncludesOperation:s {: RESULT = s; :}
				|ExcludesOperation:s {: RESULT = s; :}
				|ForAllOperation:s {: RESULT = s; :}
				|SizeOperation:s {: RESULT = s; :};
				
SelectOperation ::= SELECT LPAREN CollectionParameters:cp DOISPONTOS TypeSpecifier:ts BARRA OCLExpression:e RPAREN
				{: 
					String tab = "\t";
					String newLine = System.getProperty("line.separator");
					StringBuilder code = new StringBuilder();
					String[] vars = cp.Code.split(",");
					String[] indexes = new String[vars.length];
					String selectName = getSelectName();
					code.append("private IEnumerable " + selectName + "( ICollection collection ){" + newLine);
					code.append( "bool result = true; " + newLine);
					code.append( ts.Code + " " + cp.Code +";"+ newLine);
					for(int i = 0; i < vars.length; i++){
					  String forIndex = "index"+i;
					  indexes[i] = forIndex;
					  if (i == 0)
					  	code.append( "for(int " + indexes[i] + " = 0; " + indexes[i] + "< collection.Count(); " + indexes[i] + "++) " + newLine);
					  else
					    code.append( "for(int " + indexes[i] + " = " + indexes[i-1] + "; " + indexes[i] + "< collection.Count(); " + indexes[i] + "++) " + newLine);
					}
					code.append(  "{" + newLine);
					for(int i = 0; i < vars.length; i++)
						code.append(   vars[i] + " = collection[" + indexes[i] + "];" + newLine);
					
					code.append(  "if(" + e.Code + ")" + newLine +    "{" + newLine);
					for(int i = 0; i < vars.length; i++)
						code.append(   "yield return " + vars[i] + ";" + newLine);
					code.append(   "}");
					code.append(  "}" + newLine);
					code.append( "}" + newLine);
									
					GenAuxMethod(code.toString());
				
					RESULT = new Atributos("collection", null, selectName, SELECT);
				:}
				| SELECT LPAREN CollectionParameters:cp BARRA OCLExpression:e RPAREN
				{: 
					String tab = "\t";
					String newLine = System.getProperty("line.separator");
					StringBuilder code = new StringBuilder();
					String[] vars = cp.Code.split(",");
					String[] indexes = new String[vars.length];
					String selectName = getSelectName();
					code.append("private IEnumerable " + selectName + "( ICollection collection ){" + newLine);
					code.append( "var " + cp.Code + ";"+newLine);
					for(int i = 0; i < vars.length; i++){
					  String forIndex = "index"+i;
					  indexes[i] = forIndex;
					  if (i == 0)
					  	code.append( "for(int " + indexes[i] + " = 0; " + indexes[i] + "< collection.Count(); " + indexes[i] + "++) " + newLine);
					  else
					    code.append( "for(int " + indexes[i] + " = " + indexes[i-1] + "; " + indexes[i] + "< collection.Count(); " + indexes[i] + "++) " + newLine);
					}
					code.append(  "{" + newLine);
					for(int i = 0; i < vars.length; i++)
						code.append(   vars[i] + " = collection[" + indexes[i] + "];" + newLine);
					
					code.append(  "if(" + e.Code + ")" + newLine +    "{" + newLine);
					
					for(int i = 0; i < vars.length; i++)
						code.append(   "yield return " + vars[i] + ";" + newLine);
					code.append(  "}" + newLine);	
					code.append( "}" + newLine);
					code.append( "}" + newLine);
					
					GenAuxMethod(code.toString());
					
					RESULT = new Atributos("collection",null,selectName, SELECT);
				:}
				| SELECT LPAREN OCLExpression:e RPAREN
				{: 
					String tab = "\t";
					String newLine = System.getProperty("line.separator");
					StringBuilder code = new StringBuilder();
					String selectName = getSelectName();
					code.append("private IEnumerable " + selectName + "( ICollection collection ){" + newLine);
					
					code.append( "foreach(var v in collection) {" + newLine);					
					code.append(  "if (" + e.Code + ") yield return v;" + newLine );
					code.append( "}" + newLine);
					code.append( "}" + newLine);	
					
					GenAuxMethod(code.toString());
					
					RESULT = new Atributos("collection",null,selectName, SELECT);
				:};

ExistsOperation ::= EXISTS LPAREN CollectionParameters:cp DOISPONTOS TypeSpecifier:ts BARRA OCLExpression:e RPAREN
					{:
					String tab = "\t";
					String newLine = System.getProperty("line.separator");
					StringBuilder code = new StringBuilder();
					String[] vars = cp.Code.split(",");
					String[] indexes = new String[vars.length];
					String existsName = getExistsName();
					code.append("private bool " + existsName + "( ICollection collection ){" + newLine);
					code.append( ts.Code + " " + cp.Code +";"+ newLine);
					for(int i = 0; i < vars.length; i++){
					  String forIndex = "index"+i;
					  indexes[i] = forIndex;
					  if (i == 0)
					  	code.append( "for(int " + indexes[i] + " = 0; " + indexes[i] + "< collection.Count(); " + indexes[i] + "++) " + newLine);
					  else
					    code.append( "for(int " + indexes[i] + " = " + indexes[i-1] + "; " + indexes[i] + "< collection.Count(); " + indexes[i] + "++) " + newLine);
					}
					code.append(  "{" + newLine);
					for(int i = 0; i < vars.length; i++)
						code.append(   vars[i] + " = collection[" + indexes[i] + "];" + newLine);
					
					code.append(  "if(" + e.Code + ") return true;" + newLine );
					code.append( "}" + newLine);
					code.append("return false;" + newLine + "}");
					
					GenAuxMethod(code.toString());
					
					RESULT = new Atributos("boolean",null,existsName, EXISTS);
					:}
				| EXISTS LPAREN CollectionParameters:cp BARRA OCLExpression:e RPAREN
				{: 
					String tab = "\t";
					String newLine = System.getProperty("line.separator");
					StringBuilder code = new StringBuilder();
					String[] vars = cp.Code.split(",");
					String[] indexes = new String[vars.length];
					String existsName = getExistsName();
					code.append("private bool " + existsName + "( ICollection collection ){" + newLine);
					code.append( "var " + cp.Code + ";"+newLine);
					for(int i = 0; i < vars.length; i++){
					  String forIndex = "index"+i;
					  indexes[i] = forIndex;
					  if (i == 0)
					  	code.append( "for(int " + indexes[i] + " = 0; " + indexes[i] + "< collection.Count(); " + indexes[i] + "++) " + newLine);
					  else
					    code.append( "for(int " + indexes[i] + " = " + indexes[i-1] + "; " + indexes[i] + "< collection.Count(); " + indexes[i] + "++) " + newLine);
					}
					code.append(  "{" + newLine);
					for(int i = 0; i < vars.length; i++)
						code.append(   vars[i] + " = collection[" + indexes[i] + "];" + newLine);
					
					code.append(  "if(" + e.Code + ") return true;" + newLine );
					code.append( "}" + newLine);
					code.append("return false;" + newLine + "}");
					
					GenAuxMethod(code.toString());
					
					RESULT = new Atributos("boolean",null,existsName, EXISTS);
				:}
				| EXISTS LPAREN OCLExpression:e RPAREN
				{: 
					String tab = "\t";
					String newLine = System.getProperty("line.separator");
					StringBuilder code = new StringBuilder();
					String existsName = getExistsName();
					code.append("private bool " + existsName + "( ICollection collection ){" + newLine);
								
					
					code.append( "foreach(var v in collection) {" + newLine);					
					code.append(  "if(" + e.Code + ") return true;" + newLine );
					
					code.append("return false;" + newLine + "}");
					
					GenAuxMethod(code.toString());
					
					RESULT = new Atributos("boolean",null,existsName, EXISTS);
				:};

IncludesOperation ::= INCLUDES LPAREN ID:i RPAREN
					{:
						RESULT = new Atributos("boolean", null, "Contains(" + i.Value + ")", INCLUDES);
					:};	

ExcludesOperation ::= EXCLUDES LPAREN ID:i RPAREN
					{:
						if (!XmiParser.isValidPath(currentContext, i.Value.toString())){
							System.err.println("\nErro semantico.\nExcludesOperation ::= EXCLUDES LPAREN ID RPAREN");
							System.err.println("Identificador invalido.");
							System.exit(-1);
						} else {
							RESULT = new Atributos("boolean", null, "!Contains(" + i.Value + ")", EXCLUDES);
						}
					:};

ForAllOperation ::= FORALL LPAREN CollectionParameters:cp DOISPONTOS TypeSpecifier:ts BARRA OCLExpression:e RPAREN
				{: 
					String tab = "\t";
					String newLine = System.getProperty("line.separator");
					StringBuilder code = new StringBuilder();
					String[] vars = cp.Code.split(",");
					String[] indexes = new String[vars.length];
					String forAllName = getForAllName();
					code.append("private bool " + forAllName + "( ICollection collection ){" + newLine);
					code.append( "bool result = true; " + newLine);
					code.append( ts.Code + " " + cp.Code +";"+ newLine);
					for(int i = 0; i < vars.length; i++){
					  String forIndex = "index"+i;
					  indexes[i] = forIndex;
					  if (i == 0)
					  	code.append( "for(int " + indexes[i] + " = 0; " + indexes[i] + "< collection.Count(); " + indexes[i] + "++) " + newLine);
					  else
					    code.append( "for(int " + indexes[i] + " = " + indexes[i-1] + "; " + indexes[i] + "< collection.Count(); " + indexes[i] + "++) " + newLine);
					}
					code.append(  "{" + newLine);
					for(int i = 0; i < vars.length; i++)
						code.append(   vars[i] + " = collection[" + indexes[i] + "];" + newLine);
					
					code.append(  "result = result and " + e.Code + ";" + newLine );
					//code.append( "}" + newLine);
					code.append("return result;" + newLine + "}");
					
					GenAuxMethod(code.toString());
					
					RESULT = new Atributos("boolean",null,forAllName, FORALL);

				:}
				| FORALL LPAREN CollectionParameters:cp BARRA OCLExpression:e RPAREN
				{: 
					String tab = "\t";
					String newLine = System.getProperty("line.separator");
					StringBuilder code = new StringBuilder();
					String[] vars = cp.Code.split(",");
					String[] indexes = new String[vars.length];
					String forAllName = getForAllName();
					code.append("private bool " + forAllName + "( ICollection collection ){" + newLine);
					code.append( "bool result = true; " + newLine);
					code.append( "var " + cp.Code + ";"+newLine);
					for(int i = 0; i < vars.length; i++){
					  String forIndex = "index"+i;
					  indexes[i] = forIndex;
					  if (i == 0)
					  	code.append( "for(int " + indexes[i] + " = 0; " + indexes[i] + "< collection.Count(); " + indexes[i] + "++) " + newLine);
					  else
					    code.append( "for(int " + indexes[i] + " = " + indexes[i-1] + "; " + indexes[i] + "< collection.Count(); " + indexes[i] + "++) " + newLine);
					}
					code.append(  "{" + newLine);
					for(int i = 0; i < vars.length; i++)
						code.append(   vars[i] + " = collection[" + indexes[i] + "];" + newLine);
					
					code.append(  "result = result && (" + e.Code + ");" + newLine );
					code.append( "}" + newLine);
					code.append("return result;" + newLine + "}");
					GenAuxMethod(code.toString());
					
					RESULT = new Atributos("boolean",null,forAllName, FORALL);
 
				:}
				| FORALL LPAREN OCLExpression:e RPAREN
				{: 
				
					String tab = "\t";
					String newLine = System.getProperty("line.separator");
					StringBuilder code = new StringBuilder();
					String forAllName = getForAllName();
					code.append("private bool " + forAllName + "( ICollection collection ){" + newLine);
					code.append( "bool result = true; " + newLine);
						
					code.append( "foreach(var v in collection) {" + newLine);					
					code.append(  "result = result && ( v." + e.Code + ");" + newLine );
					code.append("}" + newLine);
					code.append("return result;" + newLine + "}");
					//code.append("}" + newLine);
					GenAuxMethod(code.toString());
					
					RESULT = new Atributos("boolean", null, forAllName, FORALL); 
				:};

SizeOperation ::= SIZE LPAREN RPAREN {: RESULT = new Atributos("integer", null, ".Count()", SIZE); :};

CollectionParameters ::= PropertyCall:p {: RESULT = p; :}
				| PropertyCall:p VIRGULA CollectionParameters:cp {: RESULT = new Atributos(null,null,p.Code + "," + cp.Code); :};		
				

//Tipos

TypeSpecifier ::= PathName:p {: RESULT = new Atributos(null,p.Value,p.Code);:}
		| INTTYPE{: RESULT = new Atributos(null,"int","int");:} 
		| REALTYPE{: RESULT = new Atributos(null,"double","double");:} 
		| VOID{: RESULT = new Atributos(null,"void","void");:} 
		| STRING{: RESULT = new Atributos(null,"string","string");:}
		| BOOLEAN{: RESULT = new Atributos(null,"boolean","boolean");:} ;
		
//Literais

PropertyCall ::= RESULT {: isResult = true; RESULT = new Atributos(getResultType(fullContext),"result","result");:}
				| PathName:p {: RESULT = p; :}
				| PathName:p LPAREN RPAREN {: RESULT = new Atributos(p.Type, p.Value.toString() + "()", p.Code + "()"); :}
				| PathName:p LPAREN FormalParameters:f RPAREN {: RESULT = new Atributos(p.Type, p.Value.toString() + "(" + f.Value.toString() + ")", p.Code + "(" + f.Code + ")"); :}
				| PathName:path PONTO PropertyCall:p {: RESULT = new Atributos(p.Type, path.Value.toString() + "." + p.Value.toString(), p.Code + "." + p.Code); :};
				
				
FormalParameters ::= FormalParameters:f1 VIRGULA FormalParameter:f2 {: RESULT = new Atributos(null, f1.Value.toString() + "," + f2.Value.toString(), f1.Code + "," + f2.Code); :}
				|FormalParameter:f {: RESULT = f; :};
							
FormalParameter ::= ID:i DOISPONTOS TypeSpecifier:t {: RESULT = new Atributos(null, i.Value.toString() + ":" + t.Value.toString(), t.Code + " " + i.Code); :}
				|PropertyCall:p {: RESULT = p; :};
				
PathName ::= ID:i 
			{: 	RESULT = new Atributos("id",i.Value,i.Value.toString()); 
			:}
		   | ID:i PONTO PathName:p 
		   		{: 
		   			if (!XmiParser.isValidPath(currentContext, i.Value.toString() + "." + p.Value.toString())){
		   				System.err.println("\nErro semantico.\nPathName ::= ID");
						System.err.println("Path invalido.");
						System.exit(-1);
		   			} else {
		   				RESULT = new Atributos(XmiParser.getType(XmiParser.getAssociationName(currentContext, i.Value.toString()), p.Value.toString()), i.Value + "." + p.Value, i.Code + "." + p.Code);	
		   			}
	   			:}	   		
		   | ID QUATROPONTOS PathName;
		
Number ::= INTEGER:i {: RESULT = new Atributos("integer", Integer.parseInt(i.Value.toString()), i.Value.toString()); :}
			| REAL:r {: RESULT = new Atributos("double", Double.parseDouble(r.Value.toString()), r.Value.toString()); :};

BoolValue ::= TRUE:t {: RESULT = new Atributos("boolean", t.Value, "true"); :}
			| FALSE:f {: RESULT = new Atributos("boolean", f.Value, "false"); :};
		
// Operadores

LogicalOperator ::= AND {: RESULT = new Atributos("string", "&&", "&&"); :}
				  | OR {: RESULT = new Atributos("string", "||", "||"); :}
				  | XOR {: RESULT = new Atributos("string", "^", "^"); :}
				  | IMPLIES {: RESULT = new Atributos("string", "implies", "implies"); :};
		
RelationalOperator ::= MAIORQ{: RESULT = new Atributos("string",">",">");:} 
					 | MAIORIGUAL{: RESULT = new Atributos("string",">=",">=");:} 
					 | MENORQ{: RESULT = new Atributos("string","<","<");:} 
					 | MENORIGUAL{: RESULT = new Atributos("string","<=","<=");:} 
					 | IGUAL{: RESULT = new Atributos("string","=","==");:} 
					 | DIFF{: RESULT = new Atributos("string","!=","!=");:};

AddOperator ::= MAIS {: RESULT = new Atributos("string","+","+");:}
				| MENOS {: RESULT = new Atributos("string","-","-");:};
				
MultiplyOperator ::= VEZES {: RESULT = new Atributos("string","*","*"); :}
				| DIVIDIR {: RESULT = new Atributos("string","/","/"); :};
				
UnaryOperator ::= NOT {: RESULT = new Atributos("string","not","!");:}
				| SETA {: RESULT = new Atributos("string","->","seta");:};
