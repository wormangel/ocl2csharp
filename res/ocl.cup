import java_cup.runtime.*;
import xmiParser.*;

action code {:
	private String currentContext;
	private String fullContext;
	
	private String getClassContext(String fullContext) {
		int index = fullContext.indexOf("::");
		return fullContext.substring(0,index);				
	}
:}

/* Terminais  */

terminal            PRE, POS, INV, SELECT, EXISTS, FORALL, IF, THEN, ELSE, IMPLIES, INCLUDES, EXCLUDES, SIZE, CONTEXT, LPAREN, RPAREN;
terminal			LCOLCH, RCOLCH, LCHAVE, RCHAVE, DOISPONTOS, QUATROPONTOS, VIRGULA, IGUAL, DIFF, MENORQ, MAIORQ, MENORIGUAL, MAIORIGUAL, SETA, PONTOPONTO;
terminal			PONTO, SHARP, PONTOVIRGULA, BARRA, MAIS, MENOS, VEZES, DIVIDIR;
terminal 			VOID, AND, OR, XOR, NOT, ENDIF, INTTYPE, REALTYPE, PACKAGE, ENDPACKAGE;
terminal Atributos	STRING, BOOLEAN, NUMBER, SET, BAG, SEQUENCE, COLLECTION, INTEGER, REAL, TRUE, FALSE, ID;


/* Não terminais */

non terminal Atributos OCLFile, OCLConstraints, Constraint, ContextDeclaration, ContextBody, Stereotype, OCLExpression, OperationContext, ClassifierContext;
non terminal Atributos OperationName, FormalParameters,  ReturnType, FormalParameter, TypeSpecifier, CollectionType, SimpleTypeSpecifier, PathName, OCLLiteral;
non terminal Atributos BoolValue, Number;

// Expressões

non terminal Atributos PostFixExpression, LogicalExpression, NumberExpression, RelationalExpression, PropertyCall, PropertyCallExpression, AdditiveExpression, MultiplicativeExpression, UnaryExpression, PrimaryExpression, InvExpression, PreExpression, EqualityExpression;

// Operadores lógicos, aritméticos e relacionais

non terminal Atributos MultiplyOperator, PostfixOperator, RelationalOperator, UnaryOperator, AddOperator, LogicalOperator;

// Expressões condicionais

non terminal Atributos ConditionalExpression, IfExpression, ImpliesExpression;

// Coleções e expressões sobre condições

non terminal Atributos CollectionItems, CollectionExpression, LiteralCollection, CollectionOperations, SelectOperation, ExistsOperation, IncludesOperation, ExcludesOperation, ForAllOperation, SizeOperation, CollectionParameters;

/* Precedência dos terminais */

precedence left IMPLIES;
precedence left XOR;
precedence left OR;
precedence left AND;
precedence left DIFF, IGUAL;
precedence left MENORIGUAL, MAIORIGUAL, MENORQ, MAIORQ;
precedence left IF, THEN, ELSE, ENDIF;
precedence left MAIS, MENOS;
precedence left VEZES, DIVIDIR;
precedence left PONTO, SETA;

/* Regras */

// Regra Inicial

start with OCLFile;

// Regras para constraints

OCLFile ::= PACKAGE ID OCLConstraints ENDPACKAGE
		  | OCLConstraints;
				
OCLConstraints ::= Constraint OCLConstraints | Constraint;

Constraint ::= ContextDeclaration ContextBody {: currentContext = null; fullContext = null; :};

ContextDeclaration ::= CONTEXT OperationContext:c {: currentContext = getClassContext((String)c.Value); fullContext = (String)c.Value; :}
					 | CONTEXT ClassifierContext:c {: currentContext = (String)c.Value; :};
				
ContextBody ::= InvExpression
			  | PreExpression;
				
InvExpression ::= INV DOISPONTOS OCLExpression 
				| INV ID DOISPONTOS OCLExpression;

PreExpression ::= PRE DOISPONTOS OCLExpression
				| PRE ID DOISPONTOS OCLExpression
				| POS DOISPONTOS OCLExpression
				| POS ID DOISPONTOS OCLExpression
				| PRE DOISPONTOS OCLExpression POS DOISPONTOS OCLExpression
				| PRE ID: DOISPONTOS OCLExpression POS ID DOISPONTOS OCLExpression;

OperationContext ::= ID:i QUATROPONTOS PropertyCall:p
					{: RESULT = new Atributos(String.class, i.Value.toString() + "::" + p.Value.toString(), ""); :}
				   | ID:i QUATROPONTOS PropertyCall:p DOISPONTOS TypeSpecifier:t
				   	{: RESULT = new Atributos(String.class, i.Value.toString() + "::" + p.Value.toString() + ":" + t.Value.toString(), ""); :};
				
ClassifierContext ::= ID:i DOISPONTOS ID
					{:
						if (!XmiParser.isValidClass(i.Value.toString())) {
							System.err.println("\nErro semantico.\nClassifierContext ::= ID DOISPONTOS ID");
							System.err.println("Classe nao existe: " + i.Value);
							System.exit(0);
						} else {
							RESULT = new Atributos(String.class, i.Value.toString(), null);
						}
					:}
					| ID:i
					{:
						if (!XmiParser.isValidClass(i.Value.toString())){
								System.err.println("\nErro semantico.\nClassifierContext ::= ID");
								System.err.println("Classe nao existe: " + i.Value);
								System.exit(0);
						} else {
							RESULT = new Atributos(String.class, i.Value.toString(), null);
						}
					:} ;

// Expressões 

OCLExpression ::= LogicalExpression:e {: RESULT = e; :};

LogicalExpression ::= RelationalExpression:e {: RESULT = e; :}
				| RelationalExpression:e1 LogicalOperator:o LogicalExpression:e2
				{:
				if (e1.Type != Boolean.class || e2.Type != Boolean.class){
					System.err.println("\nErro semantico.\nLogicalExpression ::= RelationalExpression LogicalOperator LogicalExpression");
					System.err.println("Operandos devem ser do tipo boolean.");
					System.exit(-1);
				} else {
					RESULT = new Atributos(Boolean.class, null, "");				
				}
				:};
				
RelationalExpression  ::= AdditiveExpression:e {: RESULT = e; :}  
				| AdditiveExpression:e1 RelationalOperator:o RelationalExpression:e2
				{:
				if ( (o.Value.equals("==")) || (o.Value.equals("!=")) ){
					if (e1.Type != e2.Type) {
						System.err.println("\nErro semantico.\nRelationalExpression ::= AdditiveExpression RelationalOperator RelationalExpression");
						System.err.println("Operandos devem ser do mesmo tipo para operacoes de (des)igualdade.");
						System.exit(-1);
					} else {
						RESULT = new Atributos(e1.Type, null, "");
					}
				} else {
					if (e1.Type == Integer.class && e2.Type == Integer.class) {
						RESULT = new Atributos(Integer.class, null, "");
					} else if ( (e1.Type == Integer.class && e2.Type == Double.class) || (e1.Type == Double.class && e2.Type == Integer.class) ||
							    (e1.Type == Double.class && e2.Type == Double.class) ){
					    RESULT = new Atributos(Double.class, null, "");
				    } else {
						System.err.println("\nErro semantico.\nRelationalExpression ::= AdditiveExpression RelationalOperator RelationalExpression");
						System.err.println("Operandos devem ser numeros inteiros ou reais.");
						System.exit(-1);			
					}
				}
				:};
				
AdditiveExpression ::= MultiplicativeExpression:e {: RESULT = e; :}
				| MultiplicativeExpression:e1 AddOperator:o AdditiveExpression:e2
				{:
				if (e1.Type == Integer.class && e2.Type == Integer.class) {
					RESULT = new Atributos(Integer.class, null, "");
				} else if ( (e1.Type == Integer.class && e2.Type == Double.class) || (e1.Type == Double.class && e2.Type == Integer.class) ||
						    (e1.Type == Double.class && e2.Type == Double.class) ){
				    RESULT = new Atributos(Double.class, null, "");
			    } else {
					System.err.println("\nErro semantico.\nRelationalExpression ::= AdditiveExpression RelationalOperator RelationalExpression");
					System.err.println("Operandos devem ser numeros inteiros ou reais.");
					System.exit(-1);			
				}
				:};
				
MultiplicativeExpression ::= UnaryExpression:e {: RESULT = e; :}
				| UnaryExpression:e1 MultiplyOperator:o MultiplicativeExpression:e2
				{:
				if (e1.Type == Integer.class && e2.Type == Integer.class) {
					RESULT = new Atributos(Integer.class, null, "");
				} else if ( (e1.Type == Integer.class && e2.Type == Double.class) || (e1.Type == Double.class && e2.Type == Integer.class) ||
						    (e1.Type == Double.class && e2.Type == Double.class) ){
				    RESULT = new Atributos(Double.class, null, "");
			    } else {
					System.err.println("\nErro semantico.\nRelationalExpression ::= AdditiveExpression RelationalOperator RelationalExpression");
					System.err.println("Operandos devem ser numeros inteiros ou reais.");
					System.exit(-1);			
				}
				:};
				
UnaryExpression ::= PrimaryExpression:e {: RESULT = e; :}
				| UnaryOperator UnaryExpression
				| PrimaryExpression UnaryOperator UnaryExpression;
				
PrimaryExpression ::= LiteralCollection:c {: RESULT = c; :}
				| IfExpression
				| LPAREN OCLExpression:c RPAREN {: RESULT = c; :}
				| CollectionExpression;

LiteralCollection ::= Number:n 		{: RESULT = n; :}
					| BoolValue:b 	{: RESULT = b; :}
					| STRING:s  	{: RESULT = s; :}
					| PropertyCall:p 	{: RESULT = p; :};
				
IfExpression ::= IF LogicalExpression:e1 THEN  LogicalExpression ELSE LogicalExpression ENDIF
				{:
					if (e1.Type != Boolean.class) {
						System.err.println("\nErro semantico.\nIfExpression ::= IF LogicalExpression THEN  LogicalExpression ELSE LogicalExpression ENDIF");
						System.err.println("Condicao deve ser boolean.");
						System.exit(-1);	
					}
				:};		

//Expressões em coleções	
			
CollectionExpression ::= CollectionOperations;

CollectionOperations ::= SelectOperation
				|ExistsOperation
				|IncludesOperation
				|ExcludesOperation
				|ForAllOperation
				|SizeOperation;
				
SelectOperation ::= SELECT LPAREN CollectionParameters DOISPONTOS TypeSpecifier  BARRA OCLExpression RPAREN
				| SELECT LPAREN CollectionParameters BARRA OCLExpression RPAREN
				| SELECT LPAREN OCLExpression RPAREN;

ExistsOperation ::= EXISTS LPAREN CollectionParameters DOISPONTOS TypeSpecifier BARRA OCLExpression RPAREN
				| EXISTS LPAREN CollectionParameters BARRA OCLExpression RPAREN
				| EXISTS LPAREN OCLExpression RPAREN;

IncludesOperation ::= INCLUDES LPAREN ID RPAREN;

ExcludesOperation ::= EXCLUDES LPAREN ID RPAREN;

ForAllOperation ::= FORALL LPAREN CollectionParameters DOISPONTOS TypeSpecifier BARRA OCLExpression RPAREN
				| FORALL LPAREN CollectionParameters BARRA OCLExpression RPAREN
				| FORALL LPAREN OCLExpression RPAREN;

SizeOperation ::= SIZE LPAREN RPAREN;

CollectionParameters ::= PropertyCall
				| PropertyCall VIRGULA CollectionParameters;

//Tipos

TypeSpecifier ::= PathName:p {: RESULT = new Atributos(null,p.Value,p.Code);:}
		| INTTYPE{: RESULT = new Atributos(null,"int","int");:} 
		| REALTYPE{: RESULT = new Atributos(null,"double","double");:} 
		| VOID{: RESULT = new Atributos(null,"void","void");:} 
		| STRING{: RESULT = new Atributos(null,"string","string");:}
		| BOOLEAN{: RESULT = new Atributos(null,"boolean","boolean");:} ;
		
//Literais

PropertyCall ::= PathName:p {: RESULT = p; :}
				| PathName LPAREN RPAREN
				| PathName LPAREN FormalParameters RPAREN
				| PathName PONTO PropertyCall;
				
				
FormalParameters ::= FormalParameters VIRGULA FormalParameter
				|FormalParameter;
							
FormalParameter ::= ID DOISPONTOS TypeSpecifier
				|PropertyCall;
				
PathName ::= ID:i 
			{:  if (!XmiParser.isValidPath(currentContext, i.Value.toString())){
					System.err.println("\nErro semantico.\nPathName ::= ID");
					System.err.println("Identificador invalido.");
					System.exit(-1);
				} else {
					RESULT = new Atributos(XmiParser.getType(currentContext, i.Value.toString()),i.Value,""); 
				}
			:}
		   | ID PONTO PathName
		   | ID QUATROPONTOS PathName;
		
Number ::= INTEGER:i {: RESULT = new Atributos(Integer.class, Integer.parseInt(i.Value.toString()), ""); :}
			| REAL:r {: RESULT = new Atributos(Double.class, Double.parseDouble(r.Value.toString()), ""); :};

BoolValue ::= TRUE:t {: RESULT = new Atributos(Boolean.class, t.Value, ""); :}
			| FALSE:f {: RESULT = new Atributos(Boolean.class, f.Value, ""); :};
		
// Operadores

LogicalOperator ::= AND {: RESULT = new Atributos(String.class, "&&", ""); :}
				  | OR {: RESULT = new Atributos(String.class, "||", ""); :}
				  | XOR {: RESULT = new Atributos(String.class, "^", ""); :}
				  | IMPLIES {: RESULT = new Atributos(String.class, "implies", ""); :};
		
RelationalOperator ::= MAIORQ{: RESULT = new Atributos(String.class,">",">");:} 
					 | MAIORIGUAL{: RESULT = new Atributos(String.class,">=",">=");:} 
					 | MENORQ{: RESULT = new Atributos(String.class,"<","<");:} 
					 | MENORIGUAL{: RESULT = new Atributos(String.class,"<=","<=");:} 
					 | IGUAL{: RESULT = new Atributos(String.class,"==","==");:} 
					 | DIFF{: RESULT = new Atributos(String.class,"!=","!=");:};

AddOperator ::= MAIS | MENOS;
MultiplyOperator ::= VEZES | DIVIDIR;
UnaryOperator ::= NOT | SETA;
